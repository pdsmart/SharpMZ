---------------------------------------------------------------------------------------------------------
--
-- Name:            sdram.vhd
-- Created:         September 2019
-- Original Author: Stephen J. Leary 2013-2014 
-- VHDL Author:     Philip Smart
-- Description:     Original verilog module written by Stephen J. Leary 2013-2014 for the Archimedes
--                  emulator with the MT48LC16M16 chip.
--                  The verilog has been translated into VHDL and adapted for both the system bus and
--                  the Wishbone bus undergoing extensive modifications to work with the ZPU EVO processor,
--                  specifically parameterisation and burst tuning to enhance L2 Cache Fill performance.
-- Credits:         
-- Copyright:       Copyright (c) 2013-2014, Stephen J. Leary, All rights reserved.
--                  VHDL translation, sysbus adaptation and enhancements (c) 2019 Philip Smart
--                  <philip.smart@net2net.org>
--
-- History:         September 2019  - Initial module translation to VHDL based on Stephen J. Leary's Verilog
--                                    source code.
--                  November 2019   - Adapted for the system bus for use when no Wishbone interface is
--                                    instantiated in the ZPU Evo.
--
---------------------------------------------------------------------------------------------------------
-- This source file is free software: you can redistribute it and-or modify
-- it under the terms of the GNU General Public License as published
-- by the Free Software Foundation, either version 3 of the License, or
-- (at your option) any later version.
--
-- This source file is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-- GNU General Public License for more details.
--
-- You should have received a copy of the GNU General Public License
-- along with this program.  If not, see <http:--www.gnu.org-licenses->.
---------------------------------------------------------------------------------------------------------
library ieee;
library pkgs;
library work;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use work.zpu_soc_pkg.all;
use work.zpu_pkg.all;

entity SDRAM is
    generic (
        MAX_DATACACHE_BITS          : integer := 4;                                     -- Maximum size in addr bits of 32bit datacache for burst transactions.
        SDRAM_ROWS                  : integer := 4096;                                  -- Number of Rows in the SDRAM.
        SDRAM_COLUMNS               : integer := 256;                                   -- Number of Columns in an SDRAM page (ie. 1 row).
        SDRAM_BANKS                 : integer := 4;                                     -- Number of banks in the SDRAM.
        SDRAM_DATAWIDTH             : integer := 16;                                    -- Data width of SDRAM chip (ie. 16, 32).
        SDRAM_CLK_FREQ              : integer := 100000000;                             -- Frequency of the SDRAM clock in Hertz.
        SDRAM_tRCD                  : integer := 2;                                     -- tRCD - RAS to CAS minimum period (in ns), ie. 20ns -> 2 cycles@100MHz
        SDRAM_tRP                   : integer := 2;                                     -- tRP  - Precharge delay, min time for a precharge command to complete (in ns), ie. 15ns -> 2 cycles@100MHz
        SDRAM_tRFC                  : integer := 70;                                    -- tRFC - Auto-refresh minimum time to complete (in ns), ie. 66ns
        SDRAM_tREF                  : integer := 64                                     -- tREF - period of time a complete refresh of all rows is made within (in ms).
    );
    port (
        -- SDRAM Interface
        SDRAM_CLK                   : in    std_logic;                                  -- SDRAM is accessed at given clock, frequency specified in RAM_CLK.
        SDRAM_RST                   : in    std_logic;                                  -- Reset the sdram controller.
        SDRAM_CKE                   : out   std_logic;                                  -- Clock enable.
        SDRAM_DQ                    : inout std_logic_vector(SDRAM_DATAWIDTH-1 downto 0); -- Bidirectional data bus
        SDRAM_ADDR                  : out   std_logic_vector(log2ceil(SDRAM_ROWS) - 1 downto 0);  -- Multiplexed address bus
        SDRAM_DQM                   : out   std_logic_vector(log2ceil(SDRAM_BANKS) - 1 downto 0); -- Number of byte masks dependent on number of banks.
        SDRAM_BA                    : out   std_logic_vector(log2ceil(SDRAM_BANKS) - 1 downto 0); -- Number of banks in SDRAM
        SDRAM_CS_n                  : out   std_logic;                                  -- Single chip select
        SDRAM_WE_n                  : out   std_logic;                                  -- Write enable
        SDRAM_RAS_n                 : out   std_logic;                                  -- Row address select
        SDRAM_CAS_n                 : out   std_logic;                                  -- Columns address select
        SDRAM_READY                 : out   std_logic;                                  -- SD ready.

        -- CPU Interface
        CLK                         : in    std_logic;                                  -- System master clock
        RESET                       : in    std_logic;                                  -- High active sync reset
        ADDR                        : in    std_logic_vector(log2ceil(SDRAM_ROWS * SDRAM_COLUMNS * SDRAM_BANKS) downto 0);
        DATA_IN                     : in    std_logic_vector(WORD_32BIT_RANGE);         -- Write data
        DATA_OUT                    : out   std_logic_vector(WORD_32BIT_RANGE);         -- Read data
        WRITE_BYTE                  : in    std_logic;                                  -- Write a single byte as specified in A1:A0
        WRITE_HWORD                 : in    std_logic;                                  -- Write a 16bit word as specified in A1
        CS                          : in    std_logic;                                  -- Chip Select.
        WREN                        : in    std_logic;                                  -- Write enable.
        RDEN                        : in    std_logic;                                  -- Read enable.
        BUSY                        : out   std_logic                                   -- Memory is busy, hold CPU.
    );
end SDRAM;

architecture Structure of SDRAM is

    -- Constants to define the structure of the SDRAM in bits for provisioning of signals.
    constant SDRAM_ROW_BITS         :       integer := log2ceil(SDRAM_ROWS);
    constant SDRAM_COLUMN_BITS      :       integer := log2ceil(SDRAM_COLUMNS);
    constant SDRAM_ARRAY_BITS       :       integer := log2ceil(SDRAM_ROWS * SDRAM_COLUMNS);
    constant SDRAM_BANK_BITS        :       integer := log2ceil(SDRAM_BANKS);
    constant SDRAM_ADDR_BITS        :       integer := log2ceil(SDRAM_ROWS * SDRAM_COLUMNS * SDRAM_BANKS);

    -- Command table for a standard SDRAM.
    --
    -- Name                         (Function)                                     CKE  CS#  RAS# CAS# WE# DQM ADDR      DQ
    -- COMMAND INHIBIT              (NOP)                                           H    H    X    X    X   X   X        X
    -- NO OPERATION                 (NOP)                                           H    L    H    H    H   X   X        X
    -- ACTIVE                       (select bank and activate row)                  H    L    L    H    H   X   Bank/row X
    -- READ                         (select bank and column, and start READ burst)  H    L    H    L    H   L/H Bank/col X
    -- WRITE                        (select bank and column, and start WRITE burst) H    L    H    L    L   L/H Bank/col Valid
    -- BURST TERMINATE                                                              H    L    H    H    L   X   X        Active
    -- PRECHARGE                    (Deactivate row in bank or banks)               H    L    L    H    L   X   Code     X
    -- AUTO REFRESH or SELF REFRESH (enter self refresh mode)                       H    L    L    L    H   X   X        X
    -- LOAD MODE REGISTER                                                           H    L    L    L    L   X   Op-code  X
    -- Write enable/output enable                                                   H    X    X    X    X   L   X        Active
    -- Write inhibit/output High-Z                                                  H    X    X    X    X   H   X        High-Z
    -- Self Refresh Entry                                                           L    L    L    L    H   X   X        X
    -- Self Refresh Exit            (Device is idle)                                H    H    X    X    X   X   X        X
    -- Self Refresh Exit            (Device is in Self Refresh state)               H    L    H    H    X   X   X        X
    -- Clock suspend mode Entry                                                     L    X    X    X    X   X   X        X
    -- Clock suspend mode Exit                                                      H    X    X    X    X   X   X        X
    -- Power down mode Entry        (Device is idle)                                L    H    X    X    X   X   X        X
    -- Power down mode Entry        (Device is Active)                              L    L    H    H    X   X   X        X
    -- Power down mode Exit         (Any state)                                     H    H    X    X    X   X   X        X
    -- Power down mode Exit         (Device is powered down)                        H    L    H    H    X   X   X        X

    constant CMD_INHIBIT            :       std_logic_vector(4 downto 0) := "11111";
    constant CMD_NOP                :       std_logic_vector(4 downto 0) := "10111";
    constant CMD_ACTIVE             :       std_logic_vector(4 downto 0) := "10011";
    constant CMD_READ               :       std_logic_vector(4 downto 0) := "10101";
    constant CMD_WRITE              :       std_logic_vector(4 downto 0) := "10100";
    constant CMD_BURST_TERMINATE    :       std_logic_vector(4 downto 0) := "10110";
    constant CMD_PRECHARGE          :       std_logic_vector(4 downto 0) := "10010";
    constant CMD_AUTO_REFRESH       :       std_logic_vector(4 downto 0) := "10001";
    constant CMD_LOAD_MODE          :       std_logic_vector(4 downto 0) := "10000";
    constant CMD_SELF_REFRESH_START :       std_logic_vector(4 downto 0) := "00001";
    constant CMD_SELF_REFRESH_END   :       std_logic_vector(4 downto 0) := "10110";
    constant CMD_CLOCK_SUSPEND      :       std_logic_vector(4 downto 0) := "00000";
    constant CMD_CLOCK_RESTORE      :       std_logic_vector(4 downto 0) := "10000";
    constant CMD_POWER_DOWN         :       std_logic_vector(4 downto 0) := "01000";
    constant CMD_POWER_RESTORE      :       std_logic_vector(4 downto 0) := "01100";

    -- Load Mode Register setting for a standard SDRAM.
    --
    -- xx:10  = Reserved            :
    -- 9      = Write Burst Mode    : 0 = Programmed Burst Length, 1 = Single Location Access
    -- 8:7    = Operating Mode      : 00 = Standard Operation, all other values reserved.
    -- 6:4    = CAS Latency         : 010 = 2, 011 = 3, all other values reserved.
    -- 3      = Burst Type          : 0 = Sequential, 1 = Interleaved.
    -- 2:0    = Burst Length        : When 000 = 1, 001 = 2, 010 = 4, 011 = 8, all others reserved except 111 when BT = 0 sets full page access.
    --                              | A12-A10 | A9        A8-A7  | A6 A5 A4 | A3Â      A2 A1 A0 |
    --                              | reserved| wr burst |reserved| CAS Ltncy|addr mode| burst len|
    constant WRITE_BURST_MODE       :       std_logic := '1';
    constant OP_MODE                :       std_logic_vector(1 downto 0) := "00";
    constant CAS_LATENCY            :       std_logic_vector(2 downto 0) := "011";
    constant BURST_TYPE             :       std_logic := '0';
    constant BURST_LENGTH           :       std_logic_vector(2 downto 0) := "000";
    constant MODE                   :       std_logic_vector(SDRAM_ROW_BITS-1 downto 0) := std_logic_vector(to_unsigned(to_integer(unsigned("00" & WRITE_BURST_MODE & OP_MODE & CAS_LATENCY & BURST_TYPE & BURST_LENGTH)), SDRAM_ROW_BITS)); 

    -- FSM Cycle States governed in units of time, the state changes location according to the configurable parameters to ensure correct actuation at the correct time.
    --
    constant CYCLE_PRECHARGE        :       integer := 0;                                                          -- 0
    constant CYCLE_RAS_START        :       integer := tRP;                                                        -- 3
    constant CYCLE_RAS_NEXT         :       integer := CYCLE_RAS_START  + 1;                                       -- 4
    constant CYCLE_CAS0             :       integer := CYCLE_RAS_START  + tRCD;                                    -- 3 + tRCD
    constant CYCLE_CAS1             :       integer := CYCLE_CAS0       + 1;                                       -- 4 + tRCD
    constant CYCLE_READ0            :       integer := CYCLE_CAS0       + to_integer(unsigned(CAS_LATENCY)) + 1;   -- 3 + tRCD + CAS_LATENCY
    constant CYCLE_READ1            :       integer := CYCLE_READ0      + 1;                                       -- 4 + tRCD + CAS_LATENCY
    constant CYCLE_END              :       integer := CYCLE_READ1      + 1;                                       -- 9 + tRCD + CAS_LATENCY
    constant CYCLE_RFSH_START       :       integer := tRP;                                                        -- tRP
    constant CYCLE_RFSH_END         :       integer := CYCLE_RFSH_START + ((tRFC/SDRAM_CLK_FREQ) * 10000000) + tRP + 1; -- tRP (start) + tRFC (min autorefresh time) + tRP (end) in clock ticks.

    -- Period in clock cycles between SDRAM refresh cycles. This equates to tREF / SDRAM_ROWS to evenly divide the time, then subtract the length of the refresh period as this is
    -- the time it takes when a refresh starts to completion.
    constant REFRESH_PERIOD         :       integer := (((tREF * SDRAM_CLK_FREQ ) / SDRAM_ROWS) - (tRFC * 1000)) / 1000;

    type BankArray is array(natural range 0 to 3) of std_logic_vector(SDRAM_ROW_BITS-1 downto 0);

    -- Cache for holding burst reads to allow for differing speeds of WishBone Master.
    type DataCacheArray is array(natural range 0 to ((2**(MAX_DATACACHE_BITS))-1)) of std_logic_vector(WORD_32BIT_RANGE);
    signal readCache                :       DataCacheArray;
    attribute ramstyle              :       string;
    attribute ramstyle of readCache : signal is "logic";
    signal cacheReadAddr            :       unsigned(MAX_DATACACHE_BITS-1 downto 0);
    signal cacheWriteAddr           :       unsigned(MAX_DATACACHE_BITS-1 downto 0);

    -- SDRAM domain signals.
    signal sdCycle                  :       integer range 0 to 31;
    signal sdDone                   :       std_logic;
    signal sdCmd                    :       std_logic_vector(4 downto 0);
    signal sdRefreshCount           :       unsigned(11 downto 0);
    signal sdAutoRefresh            :       std_logic;
    signal sdResetTimer             :       unsigned(7 downto 0);
    signal sdMuxAddr                :       std_logic_vector(SDRAM_ROW_BITS-1 downto 0);              -- 12+ bit multiplexed address bus
    signal sdDoneLast               :       std_logic;
    signal sdInResetCounter         :       unsigned(7 downto 0);
    signal isReady                  :       std_logic;
    signal sdDataOut                :       std_logic_vector(SDRAM_DATAWIDTH-1 downto 0);
    signal sdDataIn                 :       std_logic_vector(SDRAM_DATAWIDTH-1 downto 0);
    signal sdActiveRow              :       BankArray;
    signal sdActiveBank             :       std_logic_vector(1 downto 0);
    signal cpuBank                  :       natural range 0 to 3;
    signal cpuRow                   :       std_logic_vector(SDRAM_ROW_BITS-1 downto 0);
    signal cpuCol                   :       std_logic_vector(SDRAM_COLUMN_BITS-1 downto 0);
    signal sdDQM                    :       std_logic_vector(1 downto 0);

    -- CPU domain signals.
    signal cpuBusy                  :       std_logic;
    signal cpuDQM                   :       std_logic_vector(3 downto 0);
    signal cpuDataOut               :       std_logic_vector(WORD_32BIT_RANGE);
    signal cpuDataIn                :       std_logic_vector(WORD_32BIT_RANGE);
    signal cpuIsWriting              :       std_logic;

    signal cpuReq                   :       std_logic;
    signal cpuLastEN                :       std_logic;
    signal sdReqLast                :       std_logic;
    signal sdAck                    :       std_logic;
    signal cpuDoneAck               :       std_logic;

    type ramArray is array(natural range 0 to SDRAM_COLUMNS) of std_logic_vector(WORD_32BIT_RANGE);
    type ramCtrl is array(0 downto 0) of std_logic_vector(SDRAM_ADDR_BITS downto 0);

    shared variable READRAM : ramArray :=
    (
        others => X"00000000"
    );

    shared variable WRITERAM : ramArray :=
    (
        others => X"00000000"
    );
    shared variable WRITECTRL : ramCtrl :=
    (
        others => (others => '0')
    );
    shared variable READCTRL : ramCtrl :=
    (
        others => (others => '0')
    );

    signal cpuReadFifoBlockAddr     :       std_logic_vector(SDRAM_ADDR_BITS-1 downto SDRAM_COLUMNS);
    signal sdReadFifoBlockAddr      :       std_logic_vector(SDRAM_ADDR_BITS-1 downto SDRAM_COLUMNS);
    signal fifoSdWREN               :       std_logic;
    signal fifoCpuWREN              :       std_logic;


begin

    -- Tri-state control of the SDRAM data bus.
--    process(cpuIsWriting, SDRAM_DQ, sdDataOut)
--    begin
--        if (cpuIsWriting = '1') then
--            SDRAM_DQ                                  <= sdDataOut; 
--            sdDataIn                                  <= SDRAM_DQ;
--        else
--            SDRAM_DQ                                  <= (others => 'Z');
--            sdDataIn                                  <= SDRAM_DQ;
--        end if;
--    end process;

    -- SDRAM Side of dual port RAM.
    -- For Read:  sdDataOut         <= FIFO(sdFifoAddr)
    -- For WriteL FIFO(sdFifoAddr)  <= sdDataIn
--    process(SDRAM_CLK)
--    begin
--        if rising_edge(SDRAM_CLK) then
--            if fifoSdWREN = '1' then
--                FIFO(to_integer(unsigned(sdWriteColumnAddr(SDRAM_COLUMNS-1 downto 0)))) := sdDataIn;
--                sdDataOut(WORD_32BIT_RANGE) <= sdDataIn;
--            else
--                sdDataOut(WORD_32BIT_RANGE) <= FIFO(to_integer(unsigned(sdReadColumnAddr(SDRAM_COLUMN-1 downto 0))));
--            end if;
--        end if;
--    end process;

    -- Main FSM for SDRAM control and refresh.
    process(ALL)
    begin
        if (cpuIsWriting = '1') then
            SDRAM_DQ                                  <= sdDataOut; 
        else
            SDRAM_DQ                                  <= (others => 'Z');
        end if;
        sdDataIn                                      <= SDRAM_DQ;

        if (SDRAM_RST = '1') then
            sdResetTimer                              <= (others => '0'); -- 0 upto 127
            sdInResetCounter                          <= (others => '1'); -- 255 downto 0
            sdMuxAddr                                 <= (others => '0');
            sdAutoRefresh                             <= '0';
            sdRefreshCount                            <= (others => '0');
            sdActiveBank                              <= (others => '0');
            sdActiveRow                               <= ((others => '0'), (others => '0'), (others => '0'), (others => '0'));
            isReady                                   <= '0';
            sdCmd                                     <= CMD_AUTO_REFRESH;
            SDRAM_DQM                                 <= (others => '1');
            sdCycle                                   <= 0;
            sdDone                                    <= '0';
            cacheWriteAddr                            <= (others => '0');
            sdAck                                     <= '0';
            sdReqLast                                 <= '0';

        elsif rising_edge(SDRAM_CLK) then

            -- If no specific command given the default is NOP.
            sdCmd                                     <= CMD_NOP;

            -- Initialisation on power up or reset. The SDRAM must be given at least 200uS to initialise and a fixed setup pattern applied.
            if (isReady = '0') then
                sdResetTimer                          <= sdResetTimer  + 1;
    
                -- 1uS timer.
                if (sdResetTimer = SDRAM_CLK_FREQ/1000000) then 
                    sdResetTimer                      <= (others => '0'); 
                    sdInResetCounter                  <= sdInResetCounter - 1;        
                end if;
    
                -- Every 1uS check for the next init action.
                if (sdResetTimer = 0) then 

                    -- 200uS wait, no action as the SDRAM starts up.
                    -- ie. 255 downto 55
    
                    -- Precharge all banks
                    if(sdInResetCounter = 55) then
                        sdCmd                         <= CMD_PRECHARGE;
                        SDRAM_ADDR(10)                 <= '1';
                    end if;

                    -- 8 auto refresh commands as specified in datasheet. The RFS time is 60nS, so using a 1uS timer, issue one after
                    -- the other.
                    if(sdInResetCounter >= 40 and sdInResetCounter <= 48) then
                        sdCmd                         <= CMD_AUTO_REFRESH;
                    end if;
    
                    -- Load the Mode register with our parameters.
                    if(sdInResetCounter = 39) then
                        sdCmd                         <= CMD_LOAD_MODE;
                        SDRAM_ADDR                     <= MODE;
                    end if;

                    -- 8 auto refresh commands as specified in datasheet. The RFS time is 60nS, so using a 1uS timer, issue one after
                    -- the other.
                    if(sdInResetCounter >= 30 and sdInResetCounter <= 38) then
                        sdCmd                         <= CMD_AUTO_REFRESH;
                    end if;
    
                    -- SDRAM ready.
                    if(sdInResetCounter = 20) then
                        isReady                       <= '1';
                    end if;
                end if;

            else

                -- Counter to the next auto-refresh in sdram clock ticks.
                sdRefreshCount                        <= sdRefreshCount + 1;

                -- Store the CPU request signal state to detect a change.
                sdReqLast                             <= cpuReq;

                -- If the CPU makes an SDRAM request and we arent already processing, acknowledge it.
                -- This mechanism is used to reduce the possibility of metastability issues due to differing clocks.
                if ((sdReqLast = '0' and cpuReq = '1') and sdAck = '0') then
                    sdAck                             <= '1';
                end if;

                -- If the CPU completes its request because it detects the SDRAM ACK, remove the ACK signal as it is no longer needed.
                if ((sdReqLast = '1' and cpuReq = '0') and sdAck = '1') then
                    sdAck                             <= '0';
                end if;

                -- If the SDRAM has completed its transaction and the CPU has acknowledged it, remove the signals.
                if (sdDone = '1' and cpuDoneAck = '1') then
                    sdDone                            <= '0';
                end if;

                -- Auto refresh. On timeout it kicks in so that ROWS auto refreshes are 
                -- issued in a tRFC period. Other bus operations are stalled during this period.
                if (sdRefreshCount > REFRESH_PERIOD and sdCycle = 0) then 
                    sdAutoRefresh                     <= '1';
                    sdRefreshCount                    <= (others => '0');
                    sdCmd                             <= CMD_PRECHARGE;
                    SDRAM_ADDR(10)                    <= '1';
                    sdActiveBank                      <= (others => '0');
                    sdActiveRow                       <= ((others => '0'), (others => '0'), (others => '0'), (others => '0'));
    
                -- In auto refresh period.
                elsif (sdAutoRefresh = '1') then 
    
                    -- while the cycle is active count.
                    sdCycle                           <= sdCycle +  1;
                    case (sdCycle) is 
                        when CYCLE_RFSH_START =>
                            sdCmd                     <= CMD_AUTO_REFRESH;
    
                        when CYCLE_RFSH_END =>
                            -- reset the count.
                            sdAutoRefresh             <= '0';
                            sdCycle                   <= 0;

                        when others =>
                    end case;

                -- If we are not acknowledging a CPU request (and signals to stabilize and latch), run the FSM to refresh or service a request.
                elsif sdAck = '0' then
--                if sdAck = '0' then

                    if ((cpuBusy = '1' and sdCycle = 0) or sdCycle /= 0) then -- or (sdCycle = 0 and CS = '1')) then 
    
                        -- while the cycle is active count.
                        sdCycle                           <= sdCycle + 1;
                        case (sdCycle) is
    
                            when CYCLE_PRECHARGE =>
                                -- If the bank is not open then no need to precharge, move onto RAS.
                                if (sdActiveBank(cpuBank) = '0') then
                                    sdCycle               <= CYCLE_RAS_START;
    
                                -- If the requested row is already active, go to CAS for immediate access to this row.
                                elsif (sdActiveRow(cpuBank) = cpuRow) then
                                    sdCycle               <= CYCLE_CAS0;
    
                                -- Otherwise we close out the open bank by issuing a PRECHARGE.
                                else 
                                    sdCmd                 <= CMD_PRECHARGE;
                                    SDRAM_ADDR(10)        <= '0';
                                    SDRAM_BA              <= std_logic_vector(to_unsigned(cpuBank, SDRAM_BA'length));
                                    sdActiveBank(cpuBank) <= '0';                                                        -- Store flag to indicate which bank is being made active.
                                end if;
        
                            -- Open the requested row.
                            when CYCLE_RAS_START =>
                                sdCmd                     <= CMD_ACTIVE;
                                SDRAM_ADDR                <= cpuRow;                                                      -- Addr presented to SDRAM as row address.
                                SDRAM_BA                  <= std_logic_vector(to_unsigned(cpuBank, SDRAM_BA'length));    -- Addr presented to SDRAM as bank select.
                                sdActiveRow(cpuBank)      <= cpuRow;                                                      -- Store number of row being made active
                                sdActiveBank(cpuBank)     <= '1';                                                        -- Store flag to indicate which bank is being made active.
                         
                            when CYCLE_RAS_NEXT =>
                                SDRAM_DQM                     <= "11";                                                   -- Set DQ to tri--state.
        
                            -- this is the first CAS cycle
                            when CYCLE_CAS0 =>
                                -- Process on a 32bit boundary, this core is originally intended for a a 16bit chip so we need 2 accesses for a 32bit alignment, for a 32bit chip, remove CAS1 (TODO: Auto enable logic based on datawidth).
                                SDRAM_ADDR                 <= std_logic_vector(to_unsigned(to_integer(unsigned(cpuCol(SDRAM_COLUMN_BITS-1 downto 1) & '0')), SDRAM_ROW_BITS)); -- CAS address = Address accessing first 16bit location within the 32bit external alignment with no auto precharge
                          --      SDRAM_BA                  <= std_logic_vector(to_unsigned(cpuBank, SDRAM_BA'length));     -- Ensure bank is the correct one opened.
        
                                    SDRAM_DQM                 <= not cpuDQM(3 downto 2);
                                    sdDataOut             <= cpuDataIn((SDRAM_DATAWIDTH*2)-1 downto SDRAM_DATAWIDTH);    -- Assign corresponding data to the SDRAM databus.
                                -- If writing, setup for a write with preset mask.
                                if (cpuIsWriting = '1') then 
                                    sdCmd                 <= CMD_WRITE;
                                else
                                    -- Setup for a read.
                                    sdCmd                 <= CMD_READ;
                                    SDRAM_DQM                 <= "00";                                                       -- For reads dont mask the data output.
                                end if;
        
                            when CYCLE_CAS1 =>
                                SDRAM_ADDR                 <= std_logic_vector(to_unsigned(to_integer(unsigned(cpuCol(SDRAM_COLUMN_BITS-1 downto 1) & '1')), SDRAM_ROW_BITS)); -- CAS address = Next address accessing second 16bit location within the 32bit external alignment with no auto precharge
                          --      SDRAM_BA                  <= std_logic_vector(to_unsigned(cpuBank, SDRAM_BA'length));     -- Ensure bank is the correct one opened.
    
                                    SDRAM_DQM                 <= not cpuDQM(1 downto 0);
                                    sdDataOut             <= cpuDataIn(SDRAM_DATAWIDTH-1 downto 0);
                                -- If writing, setup for a write with preset mask.
                                if (cpuIsWriting = '1') then 
                                    sdCmd                 <= CMD_WRITE;
                                  --  sdDone                <= '1'; --not sdDone;
                                    sdCycle               <= CYCLE_END;
                                else
                                    -- Setup for a read, change to write if flag set.
                                    sdCmd                 <= CMD_READ;
                                    SDRAM_DQM                 <= "00";                                                       -- For reads dont mask the data output.
                                end if;
    
                            -- Data is available CAS Latency clocks after the read request.
                            when CYCLE_READ0 =>
                                -- If writing, then we are complete, exit else read the first word.
                                if (cpuIsWriting = '1') then
                                    sdCycle               <= CYCLE_END;
                                else
                                    cpuDataOut((SDRAM_DATAWIDTH*2)-1 downto SDRAM_DATAWIDTH) <= sdDataIn;
                                end if;
        
                            when CYCLE_READ1 =>
                                -- If writing, then we are complete, exit else read the first word.
                                if (cpuIsWriting = '1') then
                                    sdCycle               <= CYCLE_END;
                                else
                                    cpuDataOut(SDRAM_DATAWIDTH-1 downto 0) <= sdDataIn;
                                end if;
        
                            when CYCLE_END =>
                                sdDone                    <= '1'; --not sdDone;
                                sdCycle                   <= 0;
    
                            -- Other states are wait states, waiting for the correct time slot for SDRAM access.
                            when others =>
                        end case;
                    else
                        sdCycle                           <= 0;
                    end if;
                end if;
            end if;
        end if;
    end process;

    -- CPU Side of dual port RAM. 
    -- For Read:  cpuDataOut        <= FIFO(cpuFifoAddr)
    -- For Write: FIFO(cpuFifoAddr) <= cpuDataIn
--    process(CLK)
--    begin
--        if rising_edge(CLK) then
--            if fifoCpuWREN = '1' then
--                FIFO(to_integer(unsigned(cpuWriteColumnAddr(SDRAM_COLUMNS-1 downto 0)))) := cpuDataIn;
--                cpuDataOut(WORD_32BIT_RANGE) <= cpuDataIn;
--            else
--                cpuDataOut(WORD_32BIT_RANGE) <= FIFO(to_integer(unsigned(cpuReadColumnAddr(SDRAM_COLUMN-1 downto 0))));
--            end if;
--        end if;
--    end process;

    -- CPU/BUS side logic. When the CPU initiates a transaction, capture the signals and the captured values are used within the SDRAM domain. This is to prevent
    -- any changes CPU side or differing signal lengths due to CPU architecture or clock being propogated into the SDRAM domain. The CPU only needs to know
    -- when the transation is complete and data read.
    --
    process(ALL)
    begin
        if (RESET = '1') then
            sdDoneLast                                <= '0';
            cpuBusy                                   <= '0';
            cpuBank                                   <= 0;
            cpuRow                                    <= (others => '0');
            cpuCol                                    <= (others => '0');
            cpuDQM                                    <= (others => '1');
            cpuDoneAck                                <= '0';
            cpuReq                                    <= '0';
            cpuLastEN                                 <= '0';

        -- If the SDRAM isnt ready, we can only wait.
        elsif isReady = '0' then

        elsif rising_edge(CLK) then

            -- Preserve current enable state to detect activation.
            cpuLastEN <= RDEN or WREN;

            -- Detect a Chip Select state change signalling access.
            if cpuLastEN = '0' and (RDEN = '1' or WREN = '1') then
                cpuBusy                               <= '1';
                cpuIsWriting                          <= WREN;
                cpuBank                               <= to_integer(unsigned(ADDR(SDRAM_ADDR_BITS downto SDRAM_ARRAY_BITS+1)));
                cpuRow                                <= std_logic_vector(to_unsigned(to_integer(unsigned(ADDR(SDRAM_ARRAY_BITS downto SDRAM_COLUMN_BITS+1))), SDRAM_ROW_BITS));
                cpuCol                                <= ADDR(SDRAM_COLUMN_BITS downto 2) & '0';
                cpuReq                                <= '1';

                -- Preset the write selects according to the CPU signals. Let Quartus optimize as easier to read seeing all mask values.
                if(WRITE_BYTE = '1') then
                    case ADDR(1 downto 0) is
                        when "00" => cpuDQM           <= "1000";
                                     cpuDataIn        <= DATA_IN(7 downto 0) & X"000000";
                        when "01" => cpuDQM           <= "0100";
                                     cpuDataIn        <= X"00" & DATA_IN(7 downto 0) & X"0000";
                        when "10" => cpuDQM           <= "0010";
                                     cpuDataIn        <= X"0000" & DATA_IN(7 downto 0) & X"00";
                        when "11" => cpuDQM           <= "0001";
                                     cpuDataIn        <= X"000000" & DATA_IN(7 downto 0);
                        when others =>
                    end case;
                    
                elsif(WRITE_HWORD = '1') then

                    case ADDR(1) is
                        when '0' =>  cpuDQM           <= "1100";
                                     cpuDataIn        <= DATA_IN(15 downto 0) & X"0000";
                        when '1' =>  cpuDQM           <= "0011";
                                     cpuDataIn        <= X"0000" & DATA_IN(15 downto 0);
                    end case;

                else
                    -- Reads are always 32bit wide and if no part word signal is asserted, writes are 32bit.
                    cpuDataIn                         <= DATA_IN(31 downto 0);
                    cpuDQM                            <= "1111";
                end if;
            end if;

            if cpuReq = '1' and sdAck = '1' then
                cpuReq                                <= '0';
            end if;

            -- Note SDRAM activity via a previous/last signal.
            sdDoneLast                                <= sdDone;

            -- If there has been a change in the SDRAM done activity reset the signals as initiated transaction is complete.
            if (sdDoneLast = '0' and sdDone = '1') then
                cpuDoneAck                            <= '1';
            end if;

            if (sdDoneLast = '1' and sdDone = '0' and cpuDoneAck = '1') then
                cpuDoneAck                            <= '0';
                cpuBusy                               <= '0';
            end if;

        end if;
    end process;

    -- Assign stored data to the CPU bus to be read.
    DATA_OUT                                 <= cpuDataOut;

    -- drive control signals according to current command
    SDRAM_CKE                                <= sdCmd(4);
    SDRAM_CS_n                               <= sdCmd(3);
    SDRAM_RAS_n                              <= sdCmd(2);
    SDRAM_CAS_n                              <= sdCmd(1);
    SDRAM_WE_n                               <= sdCmd(0);
--    SDRAM_DQM                                <= sdDQM;
 --   SDRAM_ADDR                               <= sdMuxAddr;

    -- System bus control signals.
    BUSY                                     <= '1' when (cpuLastEN = '0' and (RDEN = '1' or WREN = '1')) else cpuBusy;
    SDRAM_READY                              <= isReady;

end Structure;
